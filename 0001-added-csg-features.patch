From 97c6477517a75658aa85da60cf5081dc50dfab95 Mon Sep 17 00:00:00 2001
From: Leszek <rhoninn11@gmail.com>
Date: Fri, 3 Oct 2025 20:49:28 +0200
Subject: [PATCH 1/2] - added csg features

---
 modules/csg/config.py                         |   1 +
 modules/csg/csg_customs.cpp                   | 501 ++++++++++++++++++
 modules/csg/csg_customs.h                     | 106 ++++
 modules/csg/doc_classes/CSGAlongTransform.xml |  20 +
 modules/csg/register_types.cpp                |   2 +
 5 files changed, 630 insertions(+)
 create mode 100644 modules/csg/csg_customs.cpp
 create mode 100644 modules/csg/csg_customs.h
 create mode 100644 modules/csg/doc_classes/CSGAlongTransform.xml

diff --git a/modules/csg/config.py b/modules/csg/config.py
index 3991b846f96..d045cf7d20f 100644
--- a/modules/csg/config.py
+++ b/modules/csg/config.py
@@ -17,6 +17,7 @@ def get_doc_classes():
         "CSGShape3D",
         "CSGSphere3D",
         "CSGTorus3D",
+        "CSGAlongTransform",
     ]
 
 
diff --git a/modules/csg/csg_customs.cpp b/modules/csg/csg_customs.cpp
new file mode 100644
index 00000000000..caf9fe720d1
--- /dev/null
+++ b/modules/csg/csg_customs.cpp
@@ -0,0 +1,501 @@
+#include "csg_customs.h"
+#include "core/math/triangulate.h"
+#include "core/math/geometry_2d.h"
+
+inline Transform3D as_transform(PackedFloat32Array farr) {
+	Vector3 vs[4] = {
+		Vector3(farr[0], farr[1], farr[2]),
+		Vector3(farr[3], farr[4], farr[5]),
+		Vector3(farr[6], farr[7], farr[8]),
+		Vector3(farr[9], farr[10], farr[11]),
+	};
+
+	return Transform3D(vs[0], vs[1], vs[2], vs[3]);
+}
+
+CSGBrush *CSGAlongTransform::_build_brush() {
+	CSGBrush *new_brush = memnew(CSGBrush);
+	if (polygon.size() < 3) {
+		return new_brush;
+	}
+
+	// Triangulate polygon shape.
+	Vector<Point2> shape_polygon = polygon;
+	if (Triangulate::get_area(shape_polygon) > 0) {
+		shape_polygon.reverse();
+	}
+	int shape_sides = shape_polygon.size();
+	Vector<int> shape_faces = Geometry2D::triangulate_polygon(shape_polygon);
+	ERR_FAIL_COND_V_MSG(shape_faces.size() < 3, new_brush, "Failed to triangulate CSGPolygon. Make sure the polygon doesn't have any intersecting edges.");
+
+	// Get polygon enclosing Rect2.
+	Rect2 shape_rect(shape_polygon[0], Vector2());
+	for (int i = 1; i < shape_sides; i++) {
+		shape_rect.expand_to(shape_polygon[i]);
+	}
+
+
+	int t_size = 12;
+	int transform_count = transform_data.size()/t_size;
+	Vector<Transform3D> ts;
+	ts.resize(transform_count);
+	for (int i = 0; i < transform_count; i++) {
+		int start = i*t_size;
+		ts.set(i, as_transform(transform_data.slice(start, start + t_size)));
+	}
+	// Calculate the number extrusions, ends and faces.
+	int extrusions = 0;
+	int extrusion_face_count = shape_sides * 2;
+	int end_count = 0;
+	int shape_face_count = shape_faces.size() / 3;
+	real_t curve_length = 1.0;
+	{ //PATH_MODE
+		extrusions = transform_count;
+		if (!path_joined) {
+			end_count = 2;
+			extrusions -= 1;
+		}
+	}
+	
+
+	int face_count = extrusions * extrusion_face_count + end_count * shape_face_count;
+
+	// Initialize variables used to create the mesh.
+	Ref<Material> base_material = get_material();
+
+	Vector<Vector3> faces;
+	Vector<Vector2> uvs;
+	Vector<bool> smooth;
+	Vector<Ref<Material>> materials;
+	Vector<bool> invert;
+
+	faces.resize(face_count * 3);
+	uvs.resize(face_count * 3);
+	smooth.resize(face_count);
+	materials.resize(face_count);
+	invert.resize(face_count);
+	int faces_removed = 0;
+
+	Vector3 *facesw = faces.ptrw();
+	Vector2 *uvsw = uvs.ptrw();
+	bool *smoothw = smooth.ptrw();
+	Ref<Material> *materialsw = materials.ptrw();
+	bool *invertw = invert.ptrw();
+
+	int face = 0;
+	Transform3D base_xform;
+	Transform3D current_xform;
+	Transform3D previous_xform;
+	Transform3D previous_previous_xform;
+	double u_step = 1.0 / extrusions;
+	if (path_u_distance > 0.0) {
+		u_step *= curve_length / path_u_distance;
+	}
+	double v_step = 1.0 / shape_sides;
+	double extrusion_step = 1.0 / extrusions;
+	{ //PATH_MODE
+		if (path_joined) {
+			extrusion_step = 1.0 / (extrusions - 1);
+		}
+		extrusion_step *= curve_length;
+	}
+
+	// Create the mesh.
+	if (end_count > 0) {
+		current_xform = ts.get(0);
+
+		// Add front end face.
+		for (int face_idx = 0; face_idx < shape_face_count; face_idx++) {
+			for (int face_vertex_idx = 0; face_vertex_idx < 3; face_vertex_idx++) {
+				// We need to reverse the rotation of the shape face vertices.
+				int index = shape_faces[face_idx * 3 + 2 - face_vertex_idx];
+				Point2 p = shape_polygon[index];
+				Point2 uv = (p - shape_rect.position) / shape_rect.size;
+
+				// Use the left side of the bottom half of the y-inverted texture.
+				uv.x = uv.x / 2;
+				uv.y = 1 - (uv.y / 2);
+
+				facesw[face * 3 + face_vertex_idx] = current_xform.xform(Vector3(p.x, p.y, 0));
+				uvsw[face * 3 + face_vertex_idx] = uv;
+			}
+
+			smoothw[face] = false;
+			materialsw[face] = base_material;
+			invertw[face] = flip_faces;
+			face++;
+		}
+	}
+
+	real_t angle_simplify_dot = Math::cos(Math::deg_to_rad(path_simplify_angle));
+	Vector3 previous_simplify_dir = Vector3(0, 0, 0);
+	int faces_combined = 0;
+
+	// Add extrusion faces.
+	for (int x0 = 0; x0 < extrusions; x0++) {
+		previous_previous_xform = previous_xform;
+		previous_xform = current_xform;
+
+		// Transform3D facing = Transform3D().looking_at(direction, current_up);
+		int x1 = (x0 + 1) % transform_count;
+		current_xform = ts[x1];
+
+		print_line(x0, x1, previous_xform, current_xform);
+
+		double u0 = (x0 - faces_combined) * u_step;
+		double u1 = ((x0 + 1) * u_step);
+		if (mode == MODE_PATH && !path_continuous_u) {
+			u0 = 0.0;
+			u1 = 1.0;
+		}
+
+		// okrążenie wogół poligonu
+		for (int y0 = 0; y0 < shape_sides; y0++) {
+			int y1 = (y0 + 1) % shape_sides;
+			// Use the top half of the texture.
+			double v0 = (y0 * v_step) / 2;
+			double v1 = ((y0 + 1) * v_step) / 2;
+
+			Vector3 v[4] = {
+				previous_xform.xform(Vector3(shape_polygon[y0].x, shape_polygon[y0].y, 0)),
+				current_xform.xform(Vector3(shape_polygon[y0].x, shape_polygon[y0].y, 0)),
+				current_xform.xform(Vector3(shape_polygon[y1].x, shape_polygon[y1].y, 0)),
+				previous_xform.xform(Vector3(shape_polygon[y1].x, shape_polygon[y1].y, 0)),
+			};
+
+			Vector2 u[4] = {
+				Vector2(u0, v0),
+				Vector2(u1, v0),
+				Vector2(u1, v1),
+				Vector2(u0, v1),
+			};
+
+			// Face 1
+			facesw[face * 3 + 0] = v[0];
+			facesw[face * 3 + 1] = v[1];
+			facesw[face * 3 + 2] = v[2];
+
+			uvsw[face * 3 + 0] = u[0];
+			uvsw[face * 3 + 1] = u[1];
+			uvsw[face * 3 + 2] = u[2];
+
+			smoothw[face] = smooth_faces;
+			invertw[face] = flip_faces;
+			materialsw[face] = base_material;
+
+			face++;
+
+			// Face 2
+			facesw[face * 3 + 0] = v[2];
+			facesw[face * 3 + 1] = v[3];
+			facesw[face * 3 + 2] = v[0];
+
+			uvsw[face * 3 + 0] = u[2];
+			uvsw[face * 3 + 1] = u[3];
+			uvsw[face * 3 + 2] = u[0];
+
+			smoothw[face] = smooth_faces;
+			invertw[face] = flip_faces;
+			materialsw[face] = base_material;
+
+			face++;
+		}
+	}
+
+	if (end_count > 1) {
+		// Add back end face.
+		for (int face_idx = 0; face_idx < shape_face_count; face_idx++) {
+			for (int face_vertex_idx = 0; face_vertex_idx < 3; face_vertex_idx++) {
+				int index = shape_faces[face_idx * 3 + face_vertex_idx];
+				Point2 p = shape_polygon[index];
+				Point2 uv = (p - shape_rect.position) / shape_rect.size;
+
+				// Use the x-inverted ride side of the bottom half of the y-inverted texture.
+				uv.x = 1 - uv.x / 2;
+				uv.y = 1 - (uv.y / 2);
+
+				facesw[face * 3 + face_vertex_idx] = current_xform.xform(Vector3(p.x, p.y, 0));
+				uvsw[face * 3 + face_vertex_idx] = uv;
+			}
+
+			smoothw[face] = false;
+			materialsw[face] = base_material;
+			invertw[face] = flip_faces;
+			face++;
+		}
+	}
+
+	face_count -= faces_removed;
+	ERR_FAIL_COND_V_MSG(face != face_count, new_brush, "Bug: Failed to create the CSGPolygon mesh correctly.");
+
+
+	if (faces_removed > 0) {
+		faces.resize(face_count * 3);
+		uvs.resize(face_count * 3);
+		smooth.resize(face_count);
+		materials.resize(face_count);
+		invert.resize(face_count);
+	}
+
+	print_line("+++ There was: ", face_count, " faces");
+	new_brush->build_from_faces(faces, uvs, smooth, materials, invert);
+
+	return new_brush;
+}
+
+void CSGAlongTransform::_notification(int p_what) {
+	if (p_what == NOTIFICATION_EXIT_TREE) {
+		if (path) {
+			path->disconnect(SceneStringName(tree_exited), callable_mp(this, &CSGAlongTransform::_path_exited));
+			path->disconnect("curve_changed", callable_mp(this, &CSGAlongTransform::_path_changed));
+			path = nullptr;
+		}
+	}
+}
+
+void CSGAlongTransform::_validate_property(PropertyInfo &p_property) const {
+	if (p_property.name.begins_with("path") && mode != MODE_PATH) {
+		p_property.usage = PROPERTY_USAGE_NONE;
+	}
+}
+
+void CSGAlongTransform::_path_changed() {
+	_make_dirty();
+	update_gizmos();
+}
+
+void CSGAlongTransform::_path_exited() {
+	path = nullptr;
+}
+
+void CSGAlongTransform::_bind_methods() {
+	ClassDB::bind_method(D_METHOD("set_transform_data", "polygon"), &CSGAlongTransform::set_transform_data);
+	ClassDB::bind_method(D_METHOD("get_transform_data"), &CSGAlongTransform::get_transform_data);
+
+	ClassDB::bind_method(D_METHOD("set_polygon", "polygon"), &CSGAlongTransform::set_polygon);
+	ClassDB::bind_method(D_METHOD("get_polygon"), &CSGAlongTransform::get_polygon);
+
+	ClassDB::bind_method(D_METHOD("set_mode", "mode"), &CSGAlongTransform::set_mode);
+	ClassDB::bind_method(D_METHOD("get_mode"), &CSGAlongTransform::get_mode);
+
+	ClassDB::bind_method(D_METHOD("set_path_node", "path"), &CSGAlongTransform::set_path_node);
+	ClassDB::bind_method(D_METHOD("get_path_node"), &CSGAlongTransform::get_path_node);
+
+	ClassDB::bind_method(D_METHOD("set_path_interval_type", "interval_type"), &CSGAlongTransform::set_path_interval_type);
+	ClassDB::bind_method(D_METHOD("get_path_interval_type"), &CSGAlongTransform::get_path_interval_type);
+
+	ClassDB::bind_method(D_METHOD("set_path_interval", "interval"), &CSGAlongTransform::set_path_interval);
+	ClassDB::bind_method(D_METHOD("get_path_interval"), &CSGAlongTransform::get_path_interval);
+
+	ClassDB::bind_method(D_METHOD("set_path_simplify_angle", "degrees"), &CSGAlongTransform::set_path_simplify_angle);
+	ClassDB::bind_method(D_METHOD("get_path_simplify_angle"), &CSGAlongTransform::get_path_simplify_angle);
+
+	ClassDB::bind_method(D_METHOD("set_path_rotation", "path_rotation"), &CSGAlongTransform::set_path_rotation);
+	ClassDB::bind_method(D_METHOD("get_path_rotation"), &CSGAlongTransform::get_path_rotation);
+
+	ClassDB::bind_method(D_METHOD("set_path_local", "enable"), &CSGAlongTransform::set_path_local);
+	ClassDB::bind_method(D_METHOD("is_path_local"), &CSGAlongTransform::is_path_local);
+
+	ClassDB::bind_method(D_METHOD("set_path_continuous_u", "enable"), &CSGAlongTransform::set_path_continuous_u);
+	ClassDB::bind_method(D_METHOD("is_path_continuous_u"), &CSGAlongTransform::is_path_continuous_u);
+
+	ClassDB::bind_method(D_METHOD("set_path_u_distance", "distance"), &CSGAlongTransform::set_path_u_distance);
+	ClassDB::bind_method(D_METHOD("get_path_u_distance"), &CSGAlongTransform::get_path_u_distance);
+
+	ClassDB::bind_method(D_METHOD("set_path_joined", "enable"), &CSGAlongTransform::set_path_joined);
+	ClassDB::bind_method(D_METHOD("is_path_joined"), &CSGAlongTransform::is_path_joined);
+
+	ClassDB::bind_method(D_METHOD("set_material", "material"), &CSGAlongTransform::set_material);
+	ClassDB::bind_method(D_METHOD("get_material"), &CSGAlongTransform::get_material);
+
+	ClassDB::bind_method(D_METHOD("set_smooth_faces", "smooth_faces"), &CSGAlongTransform::set_smooth_faces);
+	ClassDB::bind_method(D_METHOD("get_smooth_faces"), &CSGAlongTransform::get_smooth_faces);
+
+	ClassDB::bind_method(D_METHOD("_is_editable_3d_polygon"), &CSGAlongTransform::_is_editable_3d_polygon);
+
+	ADD_PROPERTY(PropertyInfo(Variant::PACKED_FLOAT32_ARRAY, "transform_data"), "set_transform_data", "get_transform_data"),
+	ADD_PROPERTY(PropertyInfo(Variant::PACKED_VECTOR2_ARRAY, "polygon"), "set_polygon", "get_polygon");
+	ADD_PROPERTY(PropertyInfo(Variant::INT, "mode", PROPERTY_HINT_ENUM, "Path"), "set_mode", "get_mode");
+	ADD_PROPERTY(PropertyInfo(Variant::NODE_PATH, "path_node", PROPERTY_HINT_NODE_PATH_VALID_TYPES, "Path3D"), "set_path_node", "get_path_node");
+	ADD_PROPERTY(PropertyInfo(Variant::INT, "path_interval_type", PROPERTY_HINT_ENUM, "Distance,Subdivide"), "set_path_interval_type", "get_path_interval_type");
+	ADD_PROPERTY(PropertyInfo(Variant::FLOAT, "path_interval", PROPERTY_HINT_RANGE, "0.01,1.0,0.01,exp,or_greater"), "set_path_interval", "get_path_interval");
+	ADD_PROPERTY(PropertyInfo(Variant::FLOAT, "path_simplify_angle", PROPERTY_HINT_RANGE, "0.0,180.0,0.1"), "set_path_simplify_angle", "get_path_simplify_angle");
+	ADD_PROPERTY(PropertyInfo(Variant::INT, "path_rotation", PROPERTY_HINT_ENUM, "Polygon,Path,PathFollow"), "set_path_rotation", "get_path_rotation");
+	ADD_PROPERTY(PropertyInfo(Variant::BOOL, "path_local"), "set_path_local", "is_path_local");
+	ADD_PROPERTY(PropertyInfo(Variant::BOOL, "path_continuous_u"), "set_path_continuous_u", "is_path_continuous_u");
+	ADD_PROPERTY(PropertyInfo(Variant::FLOAT, "path_u_distance", PROPERTY_HINT_RANGE, "0.0,10.0,0.01,or_greater,suffix:m"), "set_path_u_distance", "get_path_u_distance");
+	ADD_PROPERTY(PropertyInfo(Variant::BOOL, "path_joined"), "set_path_joined", "is_path_joined");
+	ADD_PROPERTY(PropertyInfo(Variant::BOOL, "smooth_faces"), "set_smooth_faces", "get_smooth_faces");
+	ADD_PROPERTY(PropertyInfo(Variant::OBJECT, "material", PROPERTY_HINT_RESOURCE_TYPE, "BaseMaterial3D,ShaderMaterial"), "set_material", "get_material");
+
+	BIND_ENUM_CONSTANT(MODE_PATH);
+
+	BIND_ENUM_CONSTANT(PATH_ROTATION_POLYGON);
+	BIND_ENUM_CONSTANT(PATH_ROTATION_PATH);
+	BIND_ENUM_CONSTANT(PATH_ROTATION_PATH_FOLLOW);
+
+	BIND_ENUM_CONSTANT(PATH_INTERVAL_DISTANCE);
+	BIND_ENUM_CONSTANT(PATH_INTERVAL_SUBDIVIDE);
+}
+
+void CSGAlongTransform::set_polygon(const Vector<Vector2> &p_polygon) {
+	polygon = p_polygon;
+	_make_dirty();
+	update_gizmos();
+}
+
+Vector<Vector2> CSGAlongTransform::get_polygon() const {
+	return polygon;
+}
+
+void CSGAlongTransform::set_mode(Mode p_mode) {
+	mode = p_mode;
+	_make_dirty();
+	update_gizmos();
+	notify_property_list_changed();
+}
+
+CSGAlongTransform::Mode CSGAlongTransform::get_mode() const {
+	return mode;
+}
+
+void CSGAlongTransform::set_path_continuous_u(bool p_enable) {
+	path_continuous_u = p_enable;
+	_make_dirty();
+}
+
+bool CSGAlongTransform::is_path_continuous_u() const {
+	return path_continuous_u;
+}
+
+void CSGAlongTransform::set_path_u_distance(real_t p_path_u_distance) {
+	path_u_distance = p_path_u_distance;
+	_make_dirty();
+	update_gizmos();
+}
+
+real_t CSGAlongTransform::get_path_u_distance() const {
+	return path_u_distance;
+}
+
+void CSGAlongTransform::set_path_node(const NodePath &p_path) {
+	path_node = p_path;
+	_make_dirty();
+	update_gizmos();
+}
+
+NodePath CSGAlongTransform::get_path_node() const {
+	return path_node;
+}
+
+void CSGAlongTransform::set_path_interval_type(PathIntervalType p_interval_type) {
+	path_interval_type = p_interval_type;
+	_make_dirty();
+	update_gizmos();
+}
+
+CSGAlongTransform::PathIntervalType CSGAlongTransform::get_path_interval_type() const {
+	return path_interval_type;
+}
+
+void CSGAlongTransform::set_path_interval(float p_interval) {
+	path_interval = p_interval;
+	_make_dirty();
+	update_gizmos();
+}
+
+float CSGAlongTransform::get_path_interval() const {
+	return path_interval;
+}
+
+void CSGAlongTransform::set_path_simplify_angle(float p_angle) {
+	path_simplify_angle = p_angle;
+	_make_dirty();
+	update_gizmos();
+}
+
+float CSGAlongTransform::get_path_simplify_angle() const {
+	return path_simplify_angle;
+}
+
+void CSGAlongTransform::set_path_rotation(PathRotation p_rotation) {
+	path_rotation = p_rotation;
+	_make_dirty();
+	update_gizmos();
+}
+
+CSGAlongTransform::PathRotation CSGAlongTransform::get_path_rotation() const {
+	return path_rotation;
+}
+
+void CSGAlongTransform::set_path_local(bool p_enable) {
+	path_local = p_enable;
+	_make_dirty();
+	update_gizmos();
+}
+
+bool CSGAlongTransform::is_path_local() const {
+	return path_local;
+}
+
+void CSGAlongTransform::set_path_joined(bool p_enable) {
+	path_joined = p_enable;
+	_make_dirty();
+	update_gizmos();
+}
+
+bool CSGAlongTransform::is_path_joined() const {
+	return path_joined;
+}
+
+void CSGAlongTransform::set_smooth_faces(const bool p_smooth_faces) {
+	smooth_faces = p_smooth_faces;
+	_make_dirty();
+}
+
+bool CSGAlongTransform::get_smooth_faces() const {
+	return smooth_faces;
+}
+
+void CSGAlongTransform::set_material(const Ref<Material> &p_material) {
+	material = p_material;
+	_make_dirty();
+}
+
+Ref<Material> CSGAlongTransform::get_material() const {
+	return material;
+}
+
+bool CSGAlongTransform::_is_editable_3d_polygon() const {
+	return true;
+}
+
+void CSGAlongTransform::set_transform_data(const Vector<float> &p_transform_data) {
+	transform_data = p_transform_data;
+	_make_dirty();
+	update_gizmos();
+}
+
+Vector<float> CSGAlongTransform::get_transform_data() const {
+	return transform_data;
+}
+
+
+CSGAlongTransform::CSGAlongTransform() {
+	// defaults
+	mode = MODE_PATH;
+	polygon.push_back(Vector2(0, 0));
+	polygon.push_back(Vector2(0, 1));
+	polygon.push_back(Vector2(1, 1));
+	polygon.push_back(Vector2(1, 0));
+	smooth_faces = false;
+	path_interval_type = PATH_INTERVAL_DISTANCE;
+	path_interval = 1.0;
+	path_simplify_angle = 0.0;
+	path_rotation = PATH_ROTATION_PATH_FOLLOW;
+	path_local = false;
+	path_continuous_u = true;
+	path_u_distance = 1.0;
+	path_joined = false;
+	path = nullptr;
+}
\ No newline at end of file
diff --git a/modules/csg/csg_customs.h b/modules/csg/csg_customs.h
new file mode 100644
index 00000000000..b0e20fabfb5
--- /dev/null
+++ b/modules/csg/csg_customs.h
@@ -0,0 +1,106 @@
+#pragma once
+
+#include "csg.h"
+#include "csg_shape.h"
+
+class CSGAlongTransform : public CSGPrimitive3D {
+	GDCLASS(CSGAlongTransform, CSGPrimitive3D);
+
+public:
+	enum Mode {
+		MODE_PATH
+	};
+
+	enum PathIntervalType {
+		PATH_INTERVAL_DISTANCE,
+		PATH_INTERVAL_SUBDIVIDE
+	};
+
+	enum PathRotation {
+		PATH_ROTATION_POLYGON,
+		PATH_ROTATION_PATH,
+		PATH_ROTATION_PATH_FOLLOW,
+	};
+
+private:
+	virtual CSGBrush *_build_brush() override;
+
+	Vector<float> transform_data;
+	Vector<Vector2> polygon;
+	Ref<Material> material;
+
+	Mode mode;
+
+	NodePath path_node;
+	PathIntervalType path_interval_type;
+	float path_interval;
+	float path_simplify_angle;
+	PathRotation path_rotation;
+	bool path_local;
+
+	Path3D *path = nullptr;
+
+	bool smooth_faces;
+	bool path_continuous_u;
+	real_t path_u_distance;
+	bool path_joined;
+
+	bool _is_editable_3d_polygon() const;
+
+	void _path_changed();
+	void _path_exited();
+
+protected:
+	static void _bind_methods();
+	void _validate_property(PropertyInfo &p_property) const;
+	void _notification(int p_what);
+
+public:
+	void set_transform_data(const Vector<float> &t_data);
+	Vector<float> get_transform_data() const;
+	
+	void set_polygon(const Vector<Vector2> &p_polygon);
+	Vector<Vector2> get_polygon() const;
+
+	void set_mode(Mode p_mode);
+	Mode get_mode() const;
+
+	void set_path_node(const NodePath &p_path);
+	NodePath get_path_node() const;
+
+	void set_path_interval_type(PathIntervalType p_interval_type);
+	PathIntervalType get_path_interval_type() const;
+
+	void set_path_interval(float p_interval);
+	float get_path_interval() const;
+
+	void set_path_simplify_angle(float p_angle);
+	float get_path_simplify_angle() const;
+
+	void set_path_rotation(PathRotation p_rotation);
+	PathRotation get_path_rotation() const;
+
+	void set_path_local(bool p_enable);
+	bool is_path_local() const;
+
+	void set_path_continuous_u(bool p_enable);
+	bool is_path_continuous_u() const;
+
+	void set_path_u_distance(real_t p_path_u_distance);
+	real_t get_path_u_distance() const;
+
+	void set_path_joined(bool p_enable);
+	bool is_path_joined() const;
+
+	void set_smooth_faces(bool p_smooth_faces);
+	bool get_smooth_faces() const;
+
+	void set_material(const Ref<Material> &p_material);
+	Ref<Material> get_material() const;
+
+	CSGAlongTransform();
+};
+
+VARIANT_ENUM_CAST(CSGAlongTransform::Mode)
+VARIANT_ENUM_CAST(CSGAlongTransform::PathRotation)
+VARIANT_ENUM_CAST(CSGAlongTransform::PathIntervalType)
\ No newline at end of file
diff --git a/modules/csg/doc_classes/CSGAlongTransform.xml b/modules/csg/doc_classes/CSGAlongTransform.xml
new file mode 100644
index 00000000000..ac5b810eff1
--- /dev/null
+++ b/modules/csg/doc_classes/CSGAlongTransform.xml
@@ -0,0 +1,20 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+<class name="CSGAlongTransform" inherits="CSGPrimitive3D" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../../../doc/class.xsd">
+	<brief_description>
+		A CSG Box shape.
+	</brief_description>
+	<description>
+		Pretty simillar to CSGPolygon, but with more precision, you pass exact tranforms along which mesh be generated
+	</description>
+	<tutorials>
+		<link title="Prototyping levels with CSG">$DOCS_URL/tutorials/3d/csg_tools.html</link>
+	</tutorials>
+	<members>
+		<member name="material" type="Material" setter="set_material" getter="get_material">
+			The material used to render the box.
+		</member>
+		<member name="size" type="Vector3" setter="set_size" getter="get_size" default="Vector3(1, 1, 1)">
+			The box's width, height and depth.
+		</member>
+	</members>
+</class>
diff --git a/modules/csg/register_types.cpp b/modules/csg/register_types.cpp
index 465ede4ced8..70bbb0e0741 100644
--- a/modules/csg/register_types.cpp
+++ b/modules/csg/register_types.cpp
@@ -31,6 +31,7 @@
 #include "register_types.h"
 
 #include "csg_shape.h"
+#include "csg_customs.h"
 
 #ifdef TOOLS_ENABLED
 #include "editor/csg_gizmos.h"
@@ -47,6 +48,7 @@ void initialize_csg_module(ModuleInitializationLevel p_level) {
 		GDREGISTER_CLASS(CSGTorus3D);
 		GDREGISTER_CLASS(CSGPolygon3D);
 		GDREGISTER_CLASS(CSGCombiner3D);
+		GDREGISTER_CLASS(CSGAlongTransform);
 		CSGShape3D::navmesh_parse_init();
 	}
 #ifdef TOOLS_ENABLED
-- 
2.40.0.windows.1

